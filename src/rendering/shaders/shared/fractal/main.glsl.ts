/**
 * Shared main fragment shader block for fractal raymarching
 *
 * Used by both Mandelbulb and Julia shaders. Contains:
 * - Ray setup from camera through fragment
 * - Raymarching with temporal reprojection support
 * - Normal calculation (fast/high quality modes)
 * - Multi-light PBR lighting loop
 * - SSS, fresnel, fog effects
 * - Depth and MRT output
 */
export const fractalMainBlock = `
void main() {
    vec3 ro, rd;
    vec3 worldRayDir;

    // Perspective projection: ray from camera through fragment
    ro = (uInverseModelMatrix * vec4(uCameraPosition, 1.0)).xyz;
    worldRayDir = normalize(vPosition - uCameraPosition);
    rd = normalize((uInverseModelMatrix * vec4(worldRayDir, 0.0)).xyz);

    float camDist = length(ro);
    float maxDist = camDist + BOUND_R * 2.0 + 1.0;

    vec2 tSphere = intersectSphere(ro, rd, BOUND_R);
    float sphereEntry = max(0.0, tSphere.x);

    float trap;
    bool usedTemporal;
    float d = RayMarch(ro, rd, worldRayDir, trap, usedTemporal);

    if (d > maxDist && usedTemporal) {
        usedTemporal = false;
        d = RayMarchNoTemporal(ro, rd, trap);
    }

    if (d > maxDist) discard;

    vec3 p = ro + rd * d;
    vec3 n = uFastMode ? GetNormalFast(p) : GetNormal(p);

    float ao = 1.0;
    #ifdef USE_AO
    if (uAoEnabled) {
        ao = uFastMode ? 1.0 : calcAO(p, n);
    }
    #endif

    vec3 baseHSL = rgb2hsl(uColor);
    float t = 1.0 - trap;
    vec3 surfaceColor = getColorByAlgorithm(t, n, baseHSL, p);
    surfaceColor *= (0.3 + 0.7 * ao);

    vec3 col = surfaceColor * uAmbientColor * uAmbientIntensity * uAmbientEnabled;
    vec3 viewDir = -rd;
    float totalNdotL = 0.0;

    for (int i = 0; i < MAX_LIGHTS; i++) {
        if (i >= uNumLights) break;
        if (!uLightsEnabled[i]) continue;

        vec3 l = getLightDirection(i, p);
        float attenuation = uLightIntensities[i];

        int lightType = uLightTypes[i];
        if (lightType == LIGHT_TYPE_POINT || lightType == LIGHT_TYPE_SPOT) {
            float distance = length(uLightPositions[i] - p);
            attenuation *= getDistanceAttenuation(i, distance);
        }

        if (lightType == LIGHT_TYPE_SPOT) {
            vec3 ltfDiff = p - uLightPositions[i];
            float ltfLen = length(ltfDiff);
            // Guard against light at fragment position
            vec3 lightToFrag = ltfLen > 0.0001 ? ltfDiff / ltfLen : vec3(0.0, -1.0, 0.0);
            attenuation *= getSpotAttenuation(i, lightToFrag);
        }

        if (attenuation < 0.001) continue;

        float shadow = 1.0;
        #ifdef USE_SHADOWS
        if (uShadowEnabled) {
            vec3 shadowOrigin = p + n * 0.02;
            vec3 shadowDir = l;
            float shadowMaxDist = lightType == LIGHT_TYPE_DIRECTIONAL ? 10.0 : length(uLightPositions[i] - p);
            // When fastMode is active (during animation/interaction), use low quality shadows
            int effectiveQuality = uFastMode ? 0 : uShadowQuality;
            shadow = calcSoftShadowQuality(shadowOrigin, shadowDir, 0.02, shadowMaxDist, uShadowSoftness, effectiveQuality);
        }
        #endif

        float NdotL = max(dot(n, l), 0.0);
        totalNdotL = max(totalNdotL, NdotL * attenuation * shadow);

        // GGX Specular with energy conservation
        vec3 halfDir = normalize(l + viewDir);
        // F0: mix dielectric base (0.04) with albedo for metals
        vec3 F0 = mix(vec3(0.04), surfaceColor, uMetallic);
        vec3 F = fresnelSchlick(max(dot(halfDir, viewDir), 0.0), F0);

        // Energy conservation: kS is specular reflectance, kD is diffuse
        vec3 kS = F;
        vec3 kD = (vec3(1.0) - kS) * (1.0 - uMetallic);

        // Diffuse (energy-conserved)
        col += kD * surfaceColor * uLightColors[i] * NdotL * attenuation * shadow;

        // Specular (with artist-controlled color tint)
        vec3 specular = computePBRSpecular(n, viewDir, l, uRoughness, F0);
        col += specular * uSpecularColor * uLightColors[i] * NdotL * uSpecularIntensity * attenuation * shadow;

        // Subsurface Scattering (SSS)
#ifdef USE_SSS
        if (uSssEnabled) {
            vec3 sss = computeSSS(l, viewDir, n, 0.5, uSssThickness * 4.0, 0.0, uSssJitter, gl_FragCoord.xy);
            col += sss * uSssColor * uLightColors[i] * uSssIntensity * attenuation;
        }
#endif
    }

#ifdef USE_FRESNEL
    if (uFresnelEnabled && uFresnelIntensity > 0.0) {
        float NdotV = max(dot(n, viewDir), 0.0);
        float rim = pow(1.0 - NdotV, 3.0) * uFresnelIntensity * 2.0;
        rim *= (0.3 + 0.7 * totalNdotL);
        col += uRimColor * rim;
    }
#endif

    // IBL (environment reflections)
    vec3 F0_ibl = mix(vec3(0.04), surfaceColor, uMetallic);
    col += computeIBL(n, viewDir, F0_ibl, uRoughness, uMetallic, surfaceColor);

    // Atmospheric Depth Integration (Fog)
#ifdef USE_FOG
    col = applyFog(col, d);
#endif

    vec4 worldHitPos = uModelMatrix * vec4(p, 1.0);
    vec4 clipPos = uProjectionMatrix * uViewMatrix * worldHitPos;
    // Guard against clipPos.w = 0 while preserving sign
    float clipW = abs(clipPos.w) < 0.0001
      ? (clipPos.w >= 0.0 ? 0.0001 : -0.0001)
      : clipPos.w;
    gl_FragDepth = clamp((clipPos.z / clipW) * 0.5 + 0.5, 0.0, 1.0);

    float alpha = calculateOpacityAlpha(d, sphereEntry, maxDist);
    // Guard against zero-length view normal
    vec3 viewNormalRaw = (uViewMatrix * vec4(n, 0.0)).xyz;
    float vnLen = length(viewNormalRaw);
    vec3 viewNormal = vnLen > 0.0001 ? viewNormalRaw / vnLen : vec3(0.0, 0.0, 1.0);
    gColor = vec4(col, alpha);
    gNormal = vec4(viewNormal * 0.5 + 0.5, uMetallic);
    // CRITICAL: Always write to gPosition to prevent GL_INVALID_OPERATION
    // when rendering to MRT targets with 3 attachments.
    gPosition = vec4(worldHitPos.xyz, 1.0);
}
`
