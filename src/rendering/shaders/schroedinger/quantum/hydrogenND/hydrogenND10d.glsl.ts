/**
 * Hydrogen ND for 10D - Hydrogen orbital + 7 HO dimensions
 *
 * Fully unrolled for performance.
 */
export const hydrogenND10dBlock = `
// ============================================
// Hydrogen ND - 10D (7 Extra Dimensions)
// ============================================

vec2 evalHydrogenNDPsi10D(float xND[MAX_DIM], float t) {
    float x0 = xND[0], x1 = xND[1], x2 = xND[2];
    float x3 = xND[3], x4 = xND[4], x5 = xND[5];
    float x6 = xND[6], x7 = xND[7], x8 = xND[8], x9 = xND[9];

    // EARLY EXIT 1: Check extra dimensions first (fast check)
    if (extraDimEarlyExit(7, xND)) {
        return vec2(0.0);
    }

    // 10D radius
    float r10D = sqrt(x0*x0 + x1*x1 + x2*x2 + x3*x3 + x4*x4 +
                      x5*x5 + x6*x6 + x7*x7 + x8*x8 + x9*x9);

    // EARLY EXIT 2: Check hydrogen radial threshold
    if (hydrogenRadialEarlyExit(r10D, uPrincipalN, uBohrRadius, uAzimuthalL)) {
        return vec2(0.0);
    }

    float r3D = radius3D(x0, x1, x2);

    vec2 angles = sphericalAngles3D(x0, x1, x2, r3D);
    float theta = angles.x, phi = angles.y;

    float R = hydrogenRadial(uPrincipalN, uAzimuthalL, r10D, uBohrRadius);
    float Y = evalHydrogenNDAngular(uAzimuthalL, uMagneticM, theta, phi, uUseRealOrbitals);

    // Unrolled extra dimension factors
    float ef0 = extraDimFactor(0, x3);
    float ef1 = extraDimFactor(1, x4);
    float ef2 = extraDimFactor(2, x5);
    float ef3 = extraDimFactor(3, x6);
    float ef4 = extraDimFactor(4, x7);
    float ef5 = extraDimFactor(5, x8);
    float ef6 = extraDimFactor(6, x9);
    float extraProduct = ef0 * ef1 * ef2 * ef3 * ef4 * ef5 * ef6;

    float psiReal = R * Y * extraProduct;
    return hydrogenNDTimeEvolution(psiReal, uPrincipalN, t);
}
`;
