/**
 * GroundPlaneMaterial - Custom PBR shader material for ground plane surfaces
 *
 * Uses the same GGX BRDF as other custom shaders for visual consistency.
 * Supports multi-light system, shadow maps, and IBL.
 */

import { createColorCache, updateLinearColorUniform } from '@/rendering/colors/linearCache'
import { FRAME_PRIORITY } from '@/rendering/core/framePriorities'
import {
  blurToPCFSamples,
  collectShadowDataFromScene,
  createShadowMapUniforms,
  SHADOW_MAP_SIZES,
  updateShadowMapUniforms,
} from '@/rendering/shadows'
import { UniformManager } from '@/rendering/uniforms/UniformManager'
import { useEnvironmentStore } from '@/stores/environmentStore'
import { useLightingStore } from '@/stores/lightingStore'
import { useFrame, useThree } from '@react-three/fiber'
import { forwardRef, useEffect, useMemo, useRef } from 'react'
import * as THREE from 'three'
import {
  composeGroundPlaneFragmentShader,
  composeGroundPlaneVertexShader,
} from '../shaders/groundplane/compose'

export interface GroundPlaneMaterialProps {
  color: string
  opacity: number
  side?: THREE.Side
  // Grid properties
  showGrid?: boolean
  gridColor?: string
  sectionColor?: string
  gridSpacing?: number
  gridThickness?: number
  sectionThickness?: number
  gridFadeDistance?: number
  gridFadeStrength?: number
  // Note: PBR properties (metallic, roughness, specularIntensity, specularColor)
  // are managed via UniformManager using 'pbr-ground' source
}

/**
 * Custom shader material for ground plane that matches GGX BRDF of other objects.
 */
export const GroundPlaneMaterial = forwardRef<THREE.ShaderMaterial, GroundPlaneMaterialProps>(
  function GroundPlaneMaterial({
    color,
    opacity,
    side = THREE.DoubleSide,
    showGrid = false,
    gridColor = '#3a3a3a',
    sectionColor = '#4a4a4a',
    gridSpacing = 1,
    gridThickness = 0.5,
    sectionThickness = 1.0,
    gridFadeDistance = 20,
    gridFadeStrength = 2,
  }, ref) {
    const { scene } = useThree()
    const materialRef = useRef<THREE.ShaderMaterial>(null)
    const colorCacheRef = useRef(createColorCache())



    // Get shadow settings for shader compilation
    const shadowEnabled = useLightingStore((state) => state.shadowEnabled)

    // Compile shaders
    const { glsl: fragmentShader } = useMemo(
      () => composeGroundPlaneFragmentShader({ shadows: shadowEnabled, fog: false }),
      [shadowEnabled]
    )
    const vertexShader = useMemo(() => composeGroundPlaneVertexShader(), [])

    // Create uniforms
    const uniforms = useMemo(
      () => ({
        // Material properties
        uColor: { value: new THREE.Color(color).convertSRGBToLinear() },
        uOpacity: { value: opacity },

        // Lighting and PBR uniforms (via UniformManager)
        // PBR properties (uMetallic, uRoughness, uSpecularIntensity, uSpecularColor)
        // are provided by 'pbr-ground' source
        ...UniformManager.getCombinedUniforms(['lighting', 'pbr-ground']),

        // Shadow map uniforms
        ...createShadowMapUniforms(),

        // IBL uniforms - PMREM texture (sampler2D)
        uEnvMap: { value: null },
        uEnvMapSize: { value: 256.0 },
        uIBLIntensity: { value: 1.0 },
        uIBLQuality: { value: 0 },

        // Grid uniforms
        uShowGrid: { value: showGrid },
        uGridColor: { value: new THREE.Color(gridColor).convertSRGBToLinear() },
        uSectionColor: { value: new THREE.Color(sectionColor).convertSRGBToLinear() },
        uGridSpacing: { value: gridSpacing },
        uSectionSpacing: { value: gridSpacing * 5 },
        uGridThickness: { value: gridThickness },
        uSectionThickness: { value: sectionThickness },
        uGridFadeDistance: { value: gridFadeDistance },
        uGridFadeStrength: { value: gridFadeStrength },
      }),
      // Only recreate when shader config changes, not when prop values change
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [shadowEnabled]
    )

    // Forward ref
    useEffect(() => {
      if (ref && materialRef.current) {
        if (typeof ref === 'function') {
          ref(materialRef.current)
        } else {
          ref.current = materialRef.current
        }
      }
    }, [ref])

    // Update uniforms every frame
    useFrame((state) => {
      const material = materialRef.current
      if (!material?.uniforms) return

      const u = material.uniforms
      const cache = colorCacheRef.current
      const lightingState = useLightingStore.getState()

      // Update material properties
      // Note: PBR properties (uMetallic, uRoughness, uSpecularIntensity, uSpecularColor)
      // are applied via UniformManager using 'pbr-ground' source
      updateLinearColorUniform(cache.faceColor, u.uColor!.value as THREE.Color, color)
      u.uOpacity!.value = opacity

      // Update transparency
      const isTransparent = opacity < 1
      if (material.transparent !== isTransparent) {
        material.transparent = isTransparent
        material.depthWrite = !isTransparent
        material.needsUpdate = true
      }

      // Update multi-light system and PBR
      UniformManager.applyToMaterial(material, ['lighting', 'pbr-ground'])

      // Update shadow maps
      if (shadowEnabled && lightingState.shadowEnabled) {
        const shadowData = collectShadowDataFromScene(scene, lightingState.lights)
        const shadowQuality = lightingState.shadowQuality
        const shadowMapSize = SHADOW_MAP_SIZES[shadowQuality]
        const pcfSamples = blurToPCFSamples(lightingState.shadowMapBlur)
        updateShadowMapUniforms(
          u as Record<string, { value: unknown }>,
          shadowData,
          lightingState.shadowMapBias,
          shadowMapSize,
          pcfSamples
        )
      }

      // Update IBL
      // Use scene.environment (PMREM texture) which is set at the END of each frame
      // by CubemapCapturePass. This means we read the PREVIOUS frame's environment,
      // which provides frame consistency and avoids feedback loops.
      const iblState = useEnvironmentStore.getState()
      const qualityMap = { off: 0, low: 1, high: 2 } as const
      u.uIBLQuality!.value = qualityMap[iblState.iblQuality]
      u.uIBLIntensity!.value = iblState.iblIntensity
      // Use scene.environment (PMREM texture) for IBL
      const env = state.scene.environment
      const isPMREM = env && env.mapping === THREE.CubeUVReflectionMapping
      u.uEnvMap!.value = isPMREM ? env : null
      // #region agent log
      if (!u.uEnvMap._logged && env) {
        console.log('[IBL-DEBUG] GroundPlane uEnvMap', JSON.stringify({hasEnv:!!env,mapping:env?.mapping,isPMREM,iblQuality:u.uIBLQuality?.value}));
        u.uEnvMap._logged = true;
      }
      // #endregion

      // Update grid uniforms
      u.uShowGrid!.value = showGrid
      updateLinearColorUniform(cache.gridColor, u.uGridColor!.value as THREE.Color, gridColor)
      updateLinearColorUniform(cache.sectionColor, u.uSectionColor!.value as THREE.Color, sectionColor)
      u.uGridSpacing!.value = gridSpacing
      u.uSectionSpacing!.value = gridSpacing * 5
      u.uGridThickness!.value = gridThickness
      u.uSectionThickness!.value = sectionThickness
      u.uGridFadeDistance!.value = gridFadeDistance
      u.uGridFadeStrength!.value = gridFadeStrength
    }, FRAME_PRIORITY.RENDERER_UNIFORMS)

    return (
      <shaderMaterial
        ref={materialRef}
        glslVersion={THREE.GLSL3}
        vertexShader={vertexShader}
        fragmentShader={fragmentShader}
        uniforms={uniforms}
        side={side}
        transparent={opacity < 1}
        depthWrite={opacity >= 1}
        polygonOffset={true}
        polygonOffsetFactor={1}
        polygonOffsetUnits={1}
      />
    )
  }
)
